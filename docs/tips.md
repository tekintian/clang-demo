# Clang Tips



**定义指针变量**

 

C语言中，定义变量时，在变量名 前 写一个 * 星号，这个变量就变成了对应变量类型的指针变量。必要时要加( ) 来避免优先级的问题。

 

从函数返回指针 在函数名称前面增加 * 后函数内返回数组 即可, 在接收函数指针时需要先定义指针

 

函数参数能接受指针的,也可以接受数组

 

指向指针的指针 使用 2个星号定义 ** 如: int **var

 

可以对指针进行四种算术运算：++、--、+、-

指针可以用关系运算符进行比较，如 ==、< 和 >



 

引申：C语言中，定义变量时，在定义的最前面写上typedef ，那么这个变量名就成了一种类型，即这个类型的同义词。

 

变量的地址 使用 & 符号,  如 p = &var

 

结构体 struct 成员访问使用 .  如: book.title 

 

访问指针成员 使用  -> 符号,  如:struct_pointer->title

 

 

位域 由于位域不允许跨两个字节，因此位域的长度不能大于一个字节的长度，也就是说不能超过8位二进位 , 位域可以是无名位域，这时它只用来作填充或调整位置。无名的位域是不能使用的。位域在本质上就是一种结构类型，不过其成员是按二进位分配的。

struct 位域结构名 
 {

位域列表

};

类型说明符 位域名: 位域长度 

 

**union** 共用体 **共用体**是一种特殊的数据类型，允许您在相同的内存位置存储不同的数据类型。您可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值。共用体提供了一种使用相同的内存位置的有效方式。

union [union tag] { 

   member definition; 

   member definition; 

   ... 

   member definition;

 } [one or more union variables];

 

访问共用体 使用符号 . 



**输入输出**

getChar()  putChar()

**int getchar(void)** 函数从屏幕读取下一个可用的字符，并把它返回为一个整数。这个函数在同一个时间内只会读取一个单一的字符。您可以在循环内使用这个方法，以便从屏幕上读取多个字符。

**int putchar(int c)** 函数把字符输出到屏幕上，并返回相同的字符。这个函数在同一个时间内只会输出一个单一的字符。您可以在循环内使用这个方法，以便在屏幕上输出多个字符。

 

**gets() & puts()** **函数**

**char \*gets(char \*s)** 函数从 **stdin** 读取一行到 **s** 所指向的缓冲区，直到一个终止符或 EOF。

**int puts(const char \*s)** 函数把字符串 s 和一个尾随的换行符写入到 **stdout**。

 

 

**scanf()** **和** **printf()** **函数**

在这里，应当指出的是，scanf() 期待输入的格式与您给出的 %s 和 %d 相同，这意味着您必须提供有效的输入，比如 "string integer"，如果您提供的是 "string string" 或 "integer integer"，它会被认为是错误的输入。另外，在读取字符串时，只要遇到一个空格，scanf() 就会停止读取，所以 "this is test" 对 scanf() 来说是三个字符串。

 

 

**volatile** **关键字**

volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。声明时语法：**int volatile vInt;** 当要求使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。

 

 

**字符串函数:**  

| **序号** | **函数** **&** **目的**                                      |
| -------- | ------------------------------------------------------------ |
| 1        | **strcpy(s1, s2);**  复制字符串 s2 到字符串  s1。            |
| 2        | **strcat(s1, s2);**  连接字符串 s2 到字符串  s1 的末尾。     |
| 3        | **strlen(s1);**  返回字符串 s1 的长度。                      |
| 4        | **strcmp(s1, s2);**  如果 s1 和  s2 是相同的，则返回 0；如果 s1<s2 则返回小于 0；如果  s1>s2 则返回大于 0。 |
| 5        | **strchr(s1, ch);**  返回一个指针，指向字符串 s1 中字符  ch 的第一次出现的位置。 |
| 6        | **strstr(s1, s2);**  返回一个指针，指向字符串 s1 中字符串  s2 的第一次出现的位置。 |

 

 

 

 一个宏通常写在一个单行上。但是如果宏太长，一个单行容纳不下，则使用宏延续运算符（\）。

 

**字符串常量化运算符（****#****）**

在宏定义中，当需要把一个宏的参数转换为字符串常量时，则使用字符串常量化运算符（#）。在宏中使用的该运算符有一个特定的参数或参数列表。

 

示例:

 

\#include <stdio.h>

\#define message_for(a, b) \
   printf(#a " and " #b ": We love you!\n")

int main(void)
 {
  message_for(Carole, Debra);
  return 0;
 }

当上面的代码被编译和执行时，它会产生下列结果：

Carole and Debra: We love you!

 

 

 

**标记粘贴运算符（****##****）**

 

宏定义内的标记粘贴运算符（##）会合并两个参数。它允许在宏定义中两个独立的标记被合并为一个标记。

 

**defined()** **运算符**

预处理器 **defined** 运算符是用在常量表达式中的，用来确定一个标识符是否已经使用 #define 定义过。如果指定的标识符已定义，则值为真（非零）。如果指定的标识符未定义，则值为假（零）。

 

参数化的宏

在使用带有参数的宏之前，必须使用 #define 指令定义。参数列表是括在圆括号内，且必须紧跟在宏名称的后边。宏名称和左圆括号之间不允许有空格。

例如：#define MAX(x,y) ((x) > (y) ? (x) : (y))

 

包装器 **#ifndef**

 

 

**C** **语言中** **include <>** **与****include ""** **的区别****?**

**#include < >** 引用的是编译器的类库路径里面的头文件。

**#include " "** 引用的是你程序目录的相对路径中的头文件，如果在程序目录没有找到引用的头文件则到编译器的类库路径的目录下找该头文件。

 

强制类型转换  (type_name) expression

**强制类型转换运算符**的优先级**大于除法**

 

**内存管理**

**calloc(int num, int size) 分配指定数量的连续大小的内存**

**malloc(int num) 在堆区分配一块内存,用完后需要使用 free()释放**

**realloc(void \*address, int newsize) 重新分配内存**

动态分配内存示例:

char *description;

description = (char *)malloc( 200 * sizeof(char) ); /* 动态分配内存 */ 

 

**命令行参数****:**

**argv[0]** 存储程序的名称，**argv[1]** 是一个指向第一个命令行参数的指针，*argv[n] 是最后一个参数。如果没有提供任何参数，argc 将为 1，否则，如果传递了一个参数，**argc** 将被设置为 2。

 

 首先，**strlen** 是函数，**sizeof** 是运算操作符，二者得到的结果类型为 **size_t**，即 **unsigned int** 类型。大部分编译程序在编译的时候就把 **sizeof** 计算过了，而 **strlen** 的结果要在运行的时候才能计算出来。

总结: sizeof 计算的是变量的大小，而 strlen 计算的是字符串的长度，前者不受字符 **\0** 影响，后者以 **\0** 作为长度判定依据。

如: 计算arr数组的循环次数len

int len = (int) sizeof(arr) / sizeof(*arr);

//因为sizeof 计算大小是以字节形式返回,所以这里的sizeof(arr)=56返回的结果会是数组arr大小14 * 4 所以这里需要除以 sizeof(*arr) 这个计算的是arr指针的数据类型的大小 这里arr为int 所以 sizeof(*arr) =4

 

 



